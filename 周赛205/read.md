T1.
分析：相邻的字符不同，相邻字符包括左右两边，那么当前字符选择的限制，就来自左边两边的字符，那就简单了，我们只需要选择一个 既不和左边又不和右边相等的小写字母。
思路：如何进行选择呢?
1.首先我们处理特殊情况，
（1）如果前一个字符/或者后一个字符，不存在（越界），我们设为‘#’（只需要设置为小写字母之外的字符即可）
（2）如果后一个字符为‘？’，我们同样设置为‘#’

2.处理好特殊情况后，我们很容易得到 当前字符的左右相邻的字符

3.从a~z中选择一个 既不等于左边字符 又不等于右边字符 的小写字母即可

4.当然 直接在首尾预先插入‘#’，就不同特判越界的情况（本代码未添加，比赛直接写了，没想这么多）



T2.
分析：
就是一个数组里的值，等于另外一个数组里两个元素的积

思路：
很直接，
1.预处理两个数组里所有不同元素的积
2.遍历每个数组，查询即可
注意！
数值范围爆int,要用long long

T3.
分析：
看完题目，应该比较好分析
1.要使得相邻字母不同，那么我们要 对连续且字母相同的一段区间 进行处理了
2.怎么处理，我们需要将它删除得只剩下一个字符，如何删除使得成本最小
3.当然是保留这一段中cost最大的，剩余的全删除了
4.统计删除掉的cost总和，即答案

思路：
1.用栈保存字符相等且连续的一段区间。我们用sum记录区间cost和，用mx记录区间cost最大值
2.进栈时，
（1）如果栈顶元素与当前元素相等，则进栈，更新sum和mx
（2）若不同，清空栈，计算前一段连续区间的答案，然后在进栈，更新sum和mx
没啥坑，就是注意区间长度大于1才要计算答案


T4.
分析:
这个3个图叠加在一起的问题，我们分开考虑/分析
1.首先问题是 使图联通的情况下，可以删除的最大边数，好像不太熟悉，那转换一下，->使图联通的情况下，可以添加的最小边数！！！介不是MST（最小生成树）吗！
2.如果有公共边，我们肯定用公共边对不对?因为它一条边顶两条边用啊，保证添加最少边的性质
公共边组成的子图里怎么可以最简（边最少）呢？那就是最小生成树啊！！!
3.那么对于 Alice和 Bob 的图怎么处理，使得添加的边最少呢？？
因为公共边已经处理（MST，最小生成树）好了，在公共边的基础上，如何添加边，让 Alice和 Bob 都能遍历
分别对 Alice的边和Bob 的边做MST，在公共边的基础上，分别对ALice和Bob的边集合，用kurskal添加边即可。

思路:
1.对 type3的边 单独做最小生树
2.1中最小生成树的基础上，分别type1和type==2的边做最小生成树
3.经过1和 2，我们可以得到 添加最小边数使得 图“可完全遍历”的边数 ,用总边数减去即是答案
注意:用 并查集 判断 不能 保证图可完全遍历的情况
